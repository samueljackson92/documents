%%% LaTeX Template
%%% This template can be used for both articles and reports.
%%%
%%% Copyright: http://www.howtotex.com/
%%% Date: February 2011

%%% Preamble
\documentclass[paper=a4, fontsize=11pt]{scrartcl}	% Article class of KOMA-script with 11pt font and a4 format
\usepackage[margin=0.7in]{geometry}
\usepackage[english]{babel}															% English language/hyphenation
\usepackage[protrusion=true,expansion=true]{microtype}				% Better typography
\usepackage{amsmath,amsfonts,amsthm}										% Math packages
%\usepackage{color,transparent}													% If you use color and/or transparency
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption}	% Custom captions under/above floats
\usepackage{epstopdf}																	% Converts .eps to .pdf
\usepackage{subfig}																		% Subfigures
\usepackage{booktabs}																	% Nicer tables
\usepackage[pdftex]{graphicx}

%%% Advanced verbatim environment
\usepackage{verbatim}
\usepackage{fancyvrb}
\DefineShortVerb{\|}								% delimiter to display inline verbatim text


%%% Custom sectioning (sectsty package)
\usepackage{sectsty}								% Custom sectioning (see below)
\allsectionsfont{%									% Change font of al section commands
	\usefont{OT1}{bch}{b}{n}%					% bch-b-n: CharterBT-Bold font
%	\hspace{15pt}%									% Uncomment for indentation
	}

\sectionfont{%										% Change font of \section command
	\usefont{OT1}{bch}{b}{n}%					% bch-b-n: CharterBT-Bold font
	\sectionrule{0pt}{0pt}{-5pt}{0.8pt}%	% Horizontal rule below section
	}


%%% Custom headers/footers (fancyhdr package)
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\fancyhead{}														% No page header
\fancyfoot[C]{\thepage}										% Pagenumbering at center of footer
\renewcommand{\headrulewidth}{0pt}				% Remove header underlines
\renewcommand{\footrulewidth}{0pt}				% Remove footer underlines
\setlength{\headheight}{13.6pt}

%%% Equation and float numbering
\numberwithin{equation}{section} % Equationnumbering: section.eq#
\numberwithin{figure}{section} % Figurenumbering: section.fig#
\numberwithin{table}{section}

\usepackage[parfill]{parskip}
\usepackage{float}
\usepackage{hyperref}
\usepackage[numbers]{natbib} % Tablenumbering: section.tab#

%%% Title
\title{
	\vspace{-0.5in}
	\usefont{OT1}{bch}{b}{n}
	 Reflections on TDD, Pair Programming, and Refactoring
}

% Authors
%\author{
%	\usefont{OT1}{bch}{m}{n} Samuel Jackson
%	\\ \usefont{OT1}{bch}{m}{n} University Of Aberystwyth
%	\\   \texttt{slj11@aber.ac.uk}
%}
%
\author{}
\date{}

\begin{document}


%\maketitle
\section*{CS31310 Worksheet 3: Major Project Process}

\subsection*{Outline of Project}
The title for my major project is ``visualisation and topological aspects of high dimensional data''. This is a research orientated project which will most likely involve looking at dimensionality reduction and manifold learning algorithms, applying them synthetic data where the reduced dimensionality of the data is already known and to real life samples and comparing the results. We will most likely be using breast and prostate cancer research data as the real life samples.

\subsection*{Process Outline}
Defining a process for this project is difficult for two reasons. Firstly, the major project is an individual endeavour which means that many of the practices used in software development methodologies which involve multiple people are not applicable (e.g. paired programming from XP). Secondly, being a research orientated project, it is difficult to define exactly what the end result of the project should be. These factors make the choice of specific methodology for the project non trivial and I therefore propose cherry picking appropriate concepts from different methodologies to form a process suitable for the major project.

There are several factors that immediately appear to be desirable in a methodology used for the major project. The first is that the process must be flexible. In a research orientated project the exact final outcome of project is unlikely to be specifically known at the start. An ideal process should allow reworking the design as the project progresses.

Another requirement is that regular progress should be shown to be made. My supervisor will probably become concerned about the speed of progress if I spent the first half of the project time gathering requirements and designing the system with nothing tangible to show for it. The processes therefore should include some form of metric for measuring progress, preferably with incremental value added as the project progresses.

It is also desirable that the process incorporates some kind of quality checking. The end result of this project will most likely be some kind of processing pipeline for analysis. It is therefore important that there is some confidence that each component in the pipeline is working correctly and that further modifications do not break the system. This is important so that we can be confident that the results of the system are valid.

These points suggest that a process from agile end of the methodology spectrum would be the most appropriate. The idea of XP's planning games and short iterations would allow me to capture requirements and develop the project by decomposing it into different stories which could be completed in a relatively short amount of time. This gives both a concrete set list of things ``to-do'' on the project while also being flexiable; stories can be added or dropped as required and design can wait until work on a particular story begins. Using stories and iterations for development also provides a basic metric by which to measure progress (i.e. the number of stories completed in an iteration).

I would also utilise XP's concepts of refactoring and test driven development. These two components would allow me to be flexible in the way I design the system but in a controlled way that prevents me from ``just hacking it together''. Refactoring would allow me to produce a design on the fly and testing would give me confidence to make those changes.

I would also import the concepts of YAGNI and general simplicity from XP. I think that the right approach to this project will be to write something simple first and evaluate the performance of the system then modify the design of (or add features too, see last paragraph) the system based on these results.

Finally, I would also take the concept of continuous integration. This concept is less important in an individual project where there is only one contributor, but would still be helpful. This would allow me to work on different parts in parallel without fear of breaking the system as a whole when merging changes into the large system.

\subsection*{Discussion}
I believe that strict engineering methodologies such as the waterfall methodology are not appropriate for my major project. The fact that the project is a individual effort that is unlikely to be safety critical removes the need to use such a rigid process. It is inflexible and requires far too much big design up front in a project where the end goal isn't certain. The only potentially useful feature of the waterfall methodology is that it includes definitive cut off points that show progress. However, this can be achieved in an agile approach by using small iterations and frequent releases.

In the preceding section I have suggested that concepts from XP methodology would be the correct one to use for my major project, however I do think that there are some other aspects from other methodologies that could be utilised in the project. For example, while I don't necessarily support creating a big design up front, I do think that the high level walkthrough involved in the initial stage of a feature driven approach would be useful in planning the major pieces of work to be completed during the project or during the initial design of the system. To echo what I said in the first worksheet I believe that performing a small amount of design up front, or at the start of the particular story is not a bad thing, providing it is open to change and refactoring later on.

The main reason why I suggest XP for the major project is the flexibility. The project topic is deliberately designed to be open ended and flexible. Depending on my own tastes and interests as well as what results we see as the project progresses will influence the end result of the project. Therefore I think that it is essential to use a methodology that can adapt to change. I also think having short iterations that implement a small number of stories will be important. Having an iteration period of a week would be beneficial because I am likely to meet with my supervisor at least once during this period. It would probably be at this point where a ``release'' of the project could be created. This would also provide a logical point at which to plan the next iteration's stories.

In agile terms I think that my supervisor is going to most closely resemble the customer. While it is not practical for my supervisor to be truly ``on-site'', they should at least be fairly accessible. I will be meeting with them at least once a week, possibly more, and I will probably have regular email contact with them. This also reinforces that agile will be a good fit. I can discuss with my supervisor what direction we should take and generate stories from those discussions.

Each of the major methodologies used in software engineering have their own strengths and weaknesses and there are many different aspects that I would like to incorporate into a methodology for the major project. However, features from different methodologies cannot be selected at random. Aspects of development methodologies often support one another and to include one principle in designing a process requires another to be included as well. The most obvious example that comes to mind is with an agile approach. Including refactoring into the process is desirable, but in order to be able to refactor effectively the developer needs confidence that they won't break the system. In agile this confidence is given by TDD. It is essential that complementary features are included together to avoid the issue of hacking it together. It is for this reason that I have mostly incorporated features from a single methodology.

In summary, I think that an agile, XP based approach is the correct choice of methodology for my major project. The small size of the project and team coupled with the importance of flexibility and regular, meaningful progress and the accessibility of the ``customer'' suggest that this would be an appropriate choice. Using such an approach will prevent me from falling into the trap of ``just hacking'' it together. I think that some thoughtful design will be required up front before rushing in and implementing stories, but this can be relatively informal. Stories should help me to focus me attention on specific parts of the system during weekly iterations ensuring that I make meaningful, measurable progress.

\clearpage
\bibliographystyle{unsrtnat}
\bibliography{references}
\end{document}
